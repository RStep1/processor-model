# processor-model

- Рыков Степан Олегович | P3230
- asm | risc | neum | hw | instr | struct | stream | mem | cstr | prob2
- С упрощением

## Язык программирования - Assembly

Синтаксис в расширенной БНФ.

- [ ... ] -- вхождение 0 или 1 раз
- { ... } -- повторение 0 или несколько раз
- { ... }- -- повторение 1 или несколько раз

```copy
program ::= { line }

line ::= label [ comment ] "\n"
       | instr [ comment ] "\n"
       | [ comment ] "\n"

label ::= label_name ":"

instr ::= op0
        | op1 register, (register, address | integer)
        | op2 register, register, register
        | op3 label_name
        | op4 register
        | op5 register, register

op0 ::= "halt"
      | "ret"

op1 ::= "store"
      | "ld"
      | "li"

op2 ::= "add"
      | "sub"
      | "mul"
      | "div"
      | "mod"

op3 ::= "jmp"
      | "jnz"
      | "jz"
      | "jnn"
      | "call"

op4 ::= "inc"
      | "dec"
      | "push"
      | "pop"
      | "input"
      | "output"

op5 ::= "cmp"
      | "mov"

register ::= "r" {<any of "0-9">}-

integer ::= "#" [ "-" ] { <any of "0-9"> }-

address ::= <any of *> { <any of "0-9"> }

label_name ::= <any of "a-z A-Z_"> { <any of "a-z A-Z 0-9 _"> }

comment ::= ";" <any symbols except "\n">
```

**Операции**\
Арифметические операции:

`add` - сложить значения двух регистров и записать результат в левый\
`sub` - вычесть значение правого регистра и записать результат в левый\
`mul` - умножить значения двух регистров и записать результат в левый\
`div` - разделить значение левого регистра на значение правого и записать результат в левый\
`mod` - записать в левый регистр остаток от деления значения левого регистра на значение правого\
`inc` - увеличить значение на левом входе АЛУ на 1\
`dec` - уменьшить значение не левом входе АЛУ на 1

Операции с памятью:

`store` - сохранить значение регистра в память (абсолютная адресация)\
`ld`- загрузить в регистр значение из памяти (абсолютная адресация)\
`li` - прямая загрузка значения в регистр

Инструкции перехода:

`jmp` - безусловный переход\
`jz` - переход, если флаг Z = 1\
`jnz` - переход, если флаг Z = 0\
`jnn` - переход, если флаг N = 0

Операции, использующие стек:

`push` - уменьшить SP на 1, записать значение регистра по адресу в SP\
`pop` - загрузить значение в регистр по адресу в SP, увеличить SP на 1\
`call` - вызов подпрограммы: сохранить значение IP на стек, выполнить переход по указанному адресу\
`ret` - возврат из подпрограммы: загрузить значение по SP в IP

IO:

`input` - чтение memory-mapped порта ввода\
`output` - запись в memory-mapped порт вывода

Другие инструкции:

`cmp` - вычесть правый регистр из левого, установить флаги N/Z \
`mov` - копировать значение правого регистра в левый\
`halt` - останов

**Метки**\
Метки для переходов определяются на отдельных строчках и всегда начинаются с символа `.`:

```asm
.label:
    inc
```

И в другом месте (неважно, до или после определения) сослаться на эту метку:

```asm
jmp label   ; --> `jmp 123`, где 123 - номер инструкции после объявления метки
```

На этапе трансляции вместо метки ставится адрес команды, идущей на следующей строке после метки.
В программе не может быть дублирующихся меток, определенных в разных местах с одним именем.

## Организация памяти

Модель памяти процессора:

- Память команд и данных совмещены (модель фон Неймана)
- Размер машинного слова - 4 байта
- Адресация абсолютная
- Ячейка `0` содержит команду безусловного перехода на метку `.start`
- Ячейки `1` и `2` соответствуют `memory-mapped портам ввода-вывода`'
- С ячейки `3` начинается секция `.data` для переменных. Каждая переменная реализуется списком значений. Типы переменных:
  - **Целочисленные** - отводится одна ячейка памяти `int_var: 2346`
  - **Строковые** - отводится `n + 1` последовательных ячеек памяти, последним символом является 0-терминатор `str_name: 'Some text'`
  - **Ссылочные** - отводится одна ячейка для хранения адреса переменной, на которую она ссылается `link_name: var_name`
  - **Буферные** - отводится `n` последовательных ячеек памяти входе запроса в виде `var_name: bf n`
- Для реализации подпрограмм используется указатель стека `SP`, который изначально хранит последний адрес памяти
- Инструкции `st` и `ld` в качестве второго аргумента могут принимать как регистр (тогда его значение будет загружаться в регистр адресов `AR`), так и число в качестве адреса. Прямое обращение к части с памятью команд не защищено - ответственность программиста
- Инструкция `li` предназначена только для прямой загрузки в регистр

```copy
           memory
+----------------------------+
| 00 : jump .start           |
| 01 : input port            |
| 02 : output port           |
| 03 :      ...              | 
|    part for variables      |
|           ...              |
| n  : program start         |
|           ...              |
+----------------------------+

```

## Система команд

### Особенности процессора

- Машинное слово - 4 байта, знаковое. Операции с памятью осуществляются только при помощи абсолютной адресации.

- Специальные регистры: `SP` - указатель стека (изначально содержит последний адрес памяти), `IP` - счетчик инструкций, `AR` - регистр адресов для работы с памятью.

- Регистры общего назначения: `R0`, `R1`, ... , `R7`.

- Каждый регистр выходит как на левый вход, так и на правый вход АЛУ. На выходе из АЛУ значение может быть записано в любой регистр.

- Загрузка и сохранение данных регистров реализованы на отдельных шинах.

- Поток управления: 
  - инкремент `IP` после каждой инструкции
  - переходы на инструкции осуществляются инструкциями перехода и командой `call`

### Набор инструкций

| Инструкция| Кол-во тактов      |
|-----------|--------------------|
| add       | 2                  |
| sub       | 2                  |
| mul       | 2                  |
| div       | 2                  |
| mod       | 2                  |
| inc       | 2                  |
| dec       | 2                  |
| store     | 2                  |
| ld        | 2                  |
| li        | 1                  |
| jmp       | 1                  |
| jz        | 1                  |
| jnz       | 1                  |
| push      | 3                  |
| pop       | 3                  |
| call      | 4                  |
| ret       | 3                  |
| input     | 1                  |
| output    | 1                  |
| cmp       | 1                  |
| mov       | 2                  |
| halt      | 0                  |

В таблице приведено количество тактов на цикл исполнения инструкции. Цикл выборки инструкции занимает 2 такта.

Команды `call`, `ret`, `push` и `pop` транслируются в машинный код специальным оразом (остальные транслируются однозначно):

- `call .subroutine` -> 
  1. `dec sp`
  2. `st ip, sp`
  3. `li ip, .subroutine`
- `ret` ->
  1. `ld ip, sp`
  2. `inc sp`
- `push r0` ->
  1. `dec sp`
  2. `st r0, sp`
- `pop r0` ->
  1. `ld reg, sp`
  2. `inc sp`

### Кодирование инструкций

- Машинный код сериализуется в список JSON;
- Один элемент списка - одна инструкция;
- Индекс списка - адрес инструкции. Используется для команд перехода.
- Первые три аргумента представляют собой регистры
- Четвертый аргумент используется для адресов и значений

**Структура хранения команд и переменных:**

```JSON
[
      {
            "index": "addr",
            "opcode": "command",
            "args": [
                  "reg", "reg", "reg", "reg | addr | int"
            ]
      }
]
```

```JSON
[
      {
            "index": "addr",
            "variable_name": "name",
            "value": [
                  null, null, null, "value"
            ]
      }
]
```

## Транслятор

## Тестирование
